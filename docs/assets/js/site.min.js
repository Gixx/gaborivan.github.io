/*! For license information please see site.min.js.LICENSE.txt */
(()=>{var __webpack_modules__={"./webpack/components/BarChart.js":()=>{eval("/**\n * BarChart component.\n * @param {object} utility\n * @param {boolean} verbose\n * @returns {*}\n */\nconst BarChart = function ({utility, verbose = false})\n{\n    /** @type {NodeList} */\n    let chartWrappers;\n    /** @type {number} */\n    let idCounter = 1;\n    /** @type {string} */\n    const consoleColorId = '#b47ee8';\n    /** @type {number} */\n    const currentYear = (new Date()).getFullYear();\n    /** @type {number} */\n    const currentQuarter = Math.ceil(((new Date()).getMonth() + 1) / 4);\n\n    if (!utility instanceof Utility) {\n        throw new ReferenceError('This component requires the Utility component to be loaded.');\n    }\n\n    /** @type {object} */\n    const chartStyles = utility.readStylesheetsByClassName({className: 'BarChart'});\n\n    if (!chartStyles['.BarChart .grid']) {\n        throw new Error('Cannot read CSS data for Bar Chart');\n    }\n\n    /**\n     * Counts the offset from the date info\n     *\n     * @param {string} dateInfo\n     * @param {number} rangeFrom\n     * @returns {number}\n     */\n    function getOffset(dateInfo, rangeFrom)\n    {\n        let startOffset = chartStyles['.BarChart .grid'].paddingBottom;\n\n        if (startOffset.indexOf('px') !== -1)\n            startOffset = parseInt(startOffset.replace(/px/, ''));\n        else {\n            startOffset = parseInt((parseFloat(startOffset.replace(/rem/, '')) * 10.0) + '');\n        }\n\n        let rowHeight = chartStyles['.BarChart .gridRow'].height;\n\n        if (rowHeight.indexOf('px') !== -1)\n            rowHeight = parseInt(rowHeight.replace(/px/, ''));\n        else {\n            rowHeight = parseInt((parseFloat(rowHeight.replace(/rem/, '')) * 10.0) + '');\n        }\n\n        if (dateInfo === 'today') {\n            dateInfo = currentYear+'/Q'+currentQuarter;\n        }\n\n        const yearQuarter = dateInfo.split('/Q');\n        const year = parseInt(yearQuarter[0]);\n        const quarter = parseInt(yearQuarter[1]);\n        // * 1 full year = 4 quarters, so the number of full years ((year - rangeFrom) * 4)\n        // * new year = the 4th quarter finished, so it's already counted in full years, so a not full year (quarter - 1)\n        // * The sum of full years and remaining quarters give the height of the bar: multiply with the height\n        //   of a grid row and adds the bottom position\n        return ((((year - rangeFrom) * 4) + (quarter - 1)) * rowHeight) + startOffset;\n    }\n\n    /**\n     * A Bar Chart Element.\n     *\n     * @param {HTMLDivElement|Node} HTMLElement\n     * @return {*}\n     */\n    const BarChartElement = function (HTMLElement)\n    {\n        const chartDataset = HTMLElement.querySelector('dl.chart-dataset');\n        const rangeFrom = parseInt(chartDataset.dataset.rangefrom);\n        const rangeTo = (new Date()).getFullYear()+1;\n        const labels = chartDataset.querySelectorAll('dt');\n        const bars = chartDataset.querySelectorAll('dd');\n\n        let grid = '';\n        let label = '';\n        let style = '';\n\n        for (let i = rangeTo; i >= rangeFrom; i--) {\n            for (let j = 4; j > 0; j--) {\n                label = j === 1 ? '<span>'+i+'</span>' : '';\n                style = 'gridRow';\n\n                if (j === 1) {\n                    style += ' year';\n                }\n\n                if (j === currentQuarter && i === currentYear) {\n                    style += ' thisQuarter';\n                }\n\n                grid += '<div class=\"'+style+'\">'+label+'</div>';\n            }\n        }\n\n        grid += '<div class=\"labels\">';\n        for (let index in labels) {\n            if (labels.hasOwnProperty(index)) {\n                let label = labels[index].innerText;\n                grid += '<div>'+label+'</div>';\n            }\n        }\n        grid += '</div>';\n\n        for (let index in bars) {\n            if (bars.hasOwnProperty(index)) {\n                let bar = bars[index];\n                let fromData = bar.dataset.from;\n                let toData = bar.dataset.to;\n                let skill = bar.dataset.skill;\n                let counter = parseInt(index) + 1;\n\n                let offsetBottom = getOffset(fromData, rangeFrom);\n                let offsetTop = getOffset(toData, rangeFrom);\n\n                grid += '<div class=\"skill '+skill+' col'+counter+'\" style=\"bottom: '+offsetBottom+'px; height: '+(offsetTop-offsetBottom)+'px\"></div>';\n            }\n        }\n\n        HTMLElement.innerHTML = grid;\n\n        verbose && console.info(\n            '%c[Bar Chart]%c ✚%c a Bar Chart element initialized %o',\n            'background:'+consoleColorId+';color:black;font-weight:bold;',\n            'color:green; font-weight:bold;',\n            'color:#599bd6;font-style:italic',\n            '#'+HTMLElement.getAttribute('id')\n        );\n\n        return {\n\n        }\n    }\n\n    /**\n     * Initializes the component and collects the elements.\n     */\n    const initialize = function ()\n    {\n        verbose && console.info(\n            '%c[Bar Chart]%c ...looking for Bar Chart elements.',\n            'background:'+consoleColorId+';color:black;font-weight:bold;',\n            'color:#599bd6;font-style:italic'\n        );\n\n        chartWrappers = document.querySelectorAll('.BarChart .grid');\n\n        chartWrappers.forEach(function (element) {\n            if (typeof element.component === 'undefined') {\n                /** @type {HTMLDivElement|Node} element */\n                if (!element.hasAttribute('id')) {\n                    element.setAttribute('id', 'barChart' + (idCounter++));\n                }\n\n                element.component = new BarChartElement(element);\n            }\n        });\n\n        utility.triggerEvent({element: document, eventName: 'Component.BarChart.Ready', delay: 1});\n    };\n\n    verbose && console.info(\n        '%c[Bar Chart]%c ✔%c The Bar Chart component loaded.',\n        'background:'+consoleColorId+';color:black;font-weight:bold;',\n        'color:green; font-weight:bold;',\n        'color:#599bd6; font-weight:bold;'\n    );\n\n    initialize();\n\n    return {\n\n    };\n};\n\nwindow['BarChart'] = BarChart;\n\n\n//# sourceURL=webpack://gabor-ivan-blog/./webpack/components/BarChart.js?")},"./webpack/components/Collapsible.js":()=>{eval("/**\n * Collapsible component.\n * @param {object} utility\n * @param {boolean} verbose\n * @returns {*}\n */\nconst Collapsible = function ({utility, verbose = false})\n{\n    /** @type {NodeList} */\n    let collapsibleButtons;\n    /** @type {number} */\n    let idCounter = 1;\n    /** @type {string} */\n    const consoleColorId = '#dde518';\n\n    if (!utility instanceof Utility) {\n        throw new ReferenceError('This component requires the Utility component to be loaded.');\n    }\n\n    /**\n     * Toggle a collapsible element.\n     *\n     * @param {HTMLDivElement|Node} HTMLElement\n     */\n    const toggleCollapsible = function (HTMLElement) {\n        HTMLElement.classList.toggle('active');\n\n        const content = HTMLElement.nextElementSibling;\n\n        if (content.style.maxHeight) {\n            content.style.maxHeight = null;\n        } else {\n            content.style.maxHeight = content.scrollHeight + \"px\";\n        }\n    }\n\n    /**\n     * A Collapsible Element.\n     *\n     * @param {HTMLDivElement|Node} HTMLElement\n     * @return {*}\n     */\n    const CollapsibleElement = function (HTMLElement)\n    {\n        if (!HTMLElement.nextElementSibling?.classList.contains('Collapsible__content')) {\n            return false;\n        }\n\n        HTMLElement.addEventListener('click', function(event) {\n            toggleCollapsible(event.target);\n        });\n\n        verbose && console.info(\n            '%c[Collapsible]%c ✚%c a Collapsible element initialized %o',\n            'background:'+consoleColorId+';color:black;font-weight:bold;',\n            'color:green; font-weight:bold;',\n            'color:#599bd6;font-style:italic',\n            '#'+HTMLElement.getAttribute('id')\n        );\n\n        return {\n            /**\n             * Toggle this Collapsible Element.\n             */\n            toggle: function () {\n                toggleCollapsible(HTMLElement);\n            }\n        }\n    }\n\n    /**\n     * Initializes the component and collects the elements.\n     */\n    const initialize = function ()\n    {\n        verbose && console.info(\n            '%c[Collapsible]%c ...looking for Collapsible elements.',\n            'background:'+consoleColorId+';color:black;font-weight:bold;',\n            'color:#599bd6;font-style:italic'\n        );\n\n        collapsibleButtons = document.querySelectorAll('.Collapsible');\n\n        collapsibleButtons.forEach(function (element) {\n            if (typeof element.component === 'undefined') {\n                /** @type {HTMLDivElement|Node} element */\n                if (!element.hasAttribute('id')) {\n                    element.setAttribute('id', 'collapsible' + (idCounter++));\n                }\n\n                const component = new CollapsibleElement(element);\n\n                if (!component) {\n                    element.remove();\n                }\n\n                element.component = component;\n            }\n        });\n\n        utility.triggerEvent({element: document, eventName: 'Component.Collapsible.Ready', delay: 1});\n    };\n\n    verbose && console.info(\n        '%c[Collapsible]%c ✔%c The Collapsible component loaded.',\n        'background:'+consoleColorId+';color:black;font-weight:bold;',\n        'color:green; font-weight:bold;',\n        'color:#599bd6; font-weight:bold;'\n    );\n\n    initialize();\n\n    return {\n        /**\n         * Return all collapsible button.\n         *\n         * @return {NodeList}\n         */\n        getCollapsibleButtons: function() {\n            return collapsibleButtons;\n        },\n\n        /**\n         * Toggle a collapsible element.\n         *\n         * @param {String} elementId\n         */\n        toggleCollapsibleById: function(elementId) {\n            const element = document.getElementById(elementId);\n\n            if (element && element.component instanceof CollapsibleElement) {\n                element.component.toggle();\n            }\n        }\n    };\n};\n\nwindow['Collapsible'] = Collapsible;\n\n\n//# sourceURL=webpack://gabor-ivan-blog/./webpack/components/Collapsible.js?")},"./webpack/components/CookieStorage.js":()=>{eval("/**\n * Cookie Storage component.\n *\n * @param {object} utility\n * @param {boolean} verbose\n * @returns {*}\n */\nconst CookieStorage = function ({utility, verbose = false})\n{\n    const MAX_COOKIE_EXPIRATION_DAYS = 7;\n    /** @type {string} */\n    const consoleColorId = '#606366';\n\n    if (!utility instanceof Utility) {\n        throw new ReferenceError('This component requires the Utility component to be loaded.');\n    }\n\n    /**\n     * Initialize component\n     */\n    const initialize = function()\n    {\n        utility.triggerEvent({element: document, eventName: 'Component.Cookie.Ready', delay: 1});\n    };\n\n    /**\n     * Set a cookie.\n     *\n     * @param {string} cookieName  The name of the cookie\n     * @param {string} cookieValue The value of the cookie\n     * @param {number} expirationDays Expiration days\n     * @param {boolean} standardLog Whether to log the standard info or not\n     */\n    const setCookie = function (cookieName, cookieValue, expirationDays, standardLog = true)\n    {\n        const date = new Date();\n        date.setTime(date.getTime() + (expirationDays * 24 * 60 * 60 * 1000));\n        const expires = \"expires=\"+ date.toUTCString();\n\n        standardLog && verbose && console.info(\n            '%c[Cookie Storage]%c ⚡%c Setting Cookie : %o',\n            'color:white;background:'+consoleColorId+';color:black;font-weight:bold;',\n            'color:orange;font-weight:bold',\n            'color:#599bd6;font-style:italic',\n            cookieName\n        );\n        document.cookie = cookieName + '=' + cookieValue + ';' + expires + ';path=/;SameSite=Lax' + (location.protocol === 'https:' ? ';secure' : '');\n    };\n\n    /**\n     * Retrieve a cookie value.\n     *\n     * @param {string} cookieName The name of the cookie\n     * @returns {string}\n     */\n    const getCookie = function (cookieName)\n    {\n        const name = cookieName + \"=\";\n        const decodedCookie = decodeURIComponent(document.cookie);\n        const cookieArray = decodedCookie.split(';');\n        let cookie, i, num;\n\n        for (i = 0, num = cookieArray.length; i < num; i++) {\n            cookie = cookieArray[i];\n            while (cookie.charAt(0) === ' ') {\n                cookie = cookie.substring(1);\n            }\n            if (cookie.indexOf(name) === 0) {\n                return cookie.substring(name.length, cookie.length);\n            }\n        }\n\n        return '';\n    };\n\n    /**\n     * Renew a cookie if exists.\n     *\n     * @param {string} cookieName The name of the cookie\n     * @param {number} expirationDays Expiration days of the cookie\n     */\n    const renewCookie = function(cookieName, expirationDays)\n    {\n        const cookieValue = getCookie(cookieName);\n\n        if (cookieValue !== '') {\n            verbose && console.info(\n                '%c[Cookie Storage]%c ⚡%c Renew Cookie : %o',\n                'color:white;background:'+consoleColorId+';color:black;font-weight:bold;',\n                'color:orange;font-weight:bold',\n                'color:#599bd6;font-style:italic',\n                cookieName\n            );\n\n            setCookie(cookieName, cookieValue, expirationDays, false);\n        }\n    };\n\n    /**\n     * Delete a cookie if exists.\n     *\n     * @param {string} cookieName The name of the cookie\n     */\n    const deleteCookie = function(cookieName)\n    {\n        if (getCookie(cookieName) !== '') {\n            verbose && console.info(\n                '%c[Cookie Storage]%c ⚡%c Delete Cookie : %o',\n                'color:white;background:'+consoleColorId+';color:black;font-weight:bold;',\n                'color:orange;font-weight:bold',\n                'color:#599bd6;font-style:italic',\n                cookieName\n            );\n\n            setCookie(cookieName, '', -1);\n        }\n    };\n\n    verbose && console.info(\n        '%c[Cookie Storage]%c ✔%c The Cookie Component loaded.',\n        'color:white;background:'+consoleColorId+';color:black;font-weight:bold;',\n        'color:green; font-weight:bold;',\n        'color:#599bd6; font-weight:bold;'\n    );\n\n    initialize();\n\n    return {\n        /**\n         * Set a cookie.\n         *\n         * @param {string} key  The name of the cookie\n         * @param {string} value The value of the cookie\n         * @param {boolean} session The data should be deleted when the browser session ends.\n         */\n        set: function ({key, value, session = false}) {\n            const expirationDays = session ? 0 : MAX_COOKIE_EXPIRATION_DAYS;\n\n            setCookie(key, value, expirationDays);\n        },\n\n        /**\n         * Retrieve a cookie value.\n         *\n         * @param {string} key The name of the cookie\n         * @returns {string}\n         */\n        get: function ({key}) {\n            return getCookie(key);\n        },\n\n        /**\n         * Renew a cookie if exists.\n         *\n         * @param {string} key The name of the cookie\n         * @param {boolean} session The data should be deleted when the browser session ends.\n         */\n        renew: function({key, session = false}) {\n            const expirationDays = session ? 0 : MAX_COOKIE_EXPIRATION_DAYS;\n\n            renewCookie(key, expirationDays);\n        },\n\n        /**\n         * Delete a cookie if exists.\n         *\n         * @param {string} key The name of the cookie\n         */\n        delete: function(key) {\n            deleteCookie(key);\n        },\n    }\n};\n\nwindow['CookieStorage'] = CookieStorage;\n\n\n//# sourceURL=webpack://gabor-ivan-blog/./webpack/components/CookieStorage.js?")},"./webpack/components/DataStorage.js":()=>{eval("/**\n * Data Storage component.\n *\n * @param {object} utility\n * @param {boolean} verbose\n * @returns {*}\n */\nconst DataStorage = function ({utility, verbose = false})\n{\n    /** @type {string} */\n    const consoleColorId = '#13D225';\n    /** @type {object} */\n    const storage = {};\n\n    if (!utility instanceof Utility) {\n        throw new ReferenceError('This component requires the Utility component to be loaded.');\n    }\n\n    if (typeof(Storage) === 'undefined') {\n        throw new ReferenceError('Your browser does not support the local/session storage feature.');\n    }\n\n    /**\n     * Initialize component\n     */\n    const initialize = function()\n    {\n        initStorageKeys(localStorage);\n        initStorageKeys(sessionStorage);\n\n        utility.triggerEvent({element: document, eventName: 'Component.DataStorage.Ready', delay: 1});\n    };\n\n    /**\n     * Fills up the registry.\n     *\n     * @param storageEngine\n     */\n    const initStorageKeys = function(storageEngine)\n    {\n        const storageKeys = Object.keys(storageEngine);\n        let i = storageKeys.length;\n\n        while (i--) {\n            storage[storageKeys[i]] = storageEngine;\n        }\n    };\n\n    /**\n     * Set data.\n     *\n     * @param {string} key      The name of the key\n     * @param {string} value    The value\n     * @param {boolean} session Mark it as session data (for the logging only)\n     */\n    const setData = function (key, value, session = false)\n    {\n        verbose && console.info(\n            '%c[Data Storage]%c ⚡%c Setting data into dataStorage: %o'+(session ? ' (session)' : ''),\n            'background:'+consoleColorId+';color:black;font-weight:bold;',\n            'color:orange;font-weight:bold',\n            'color:#599bd6;font-style:italic',\n            key\n        );\n        typeof storage[key] !== 'undefined' && storage[key].setItem(key, value);\n    };\n\n    /**\n     * Retrieve data by key.\n     *\n     * @param {string} key The name of the key\n     * @returns {string}\n     */\n    const getDataByKey = function (key)\n    {\n        return typeof storage[key] !== 'undefined'\n            ? storage[key].getItem(key)\n            : '';\n    };\n\n    /**\n     * Delete data by key.\n     *\n     * @param {string} key The name of the key\n     */\n    const deleteDataByKey = function(key)\n    {\n        typeof storage[key] !== 'undefined' && storage[key].removeItem(key);\n    };\n\n    verbose && console.info(\n        '%c[Data Storage]%c ✔%c The Data Storage Component loaded.',\n        'background:'+consoleColorId+';color:black;font-weight:bold;',\n        'color:green; font-weight:bold;',\n        'color:#599bd6; font-weight:bold;'\n    );\n\n    initialize();\n\n    return {\n        /**\n         * Set data.\n         *\n         * @param {string} key   The name of the key\n         * @param {string} value The value\n         * @param {boolean} session The data should be deleted when the browser session ends.\n         */\n        set: function ({key, value, session = false}) {\n            // To avoid to leave mess in local storage when setting an existing key to session storage, first we delete.\n            deleteDataByKey(key);\n\n            storage[key] = session ? sessionStorage : localStorage;\n\n            setData(key, value, session);\n        },\n\n        /**\n         * Retrieve data by key.\n         *\n         * @param {string} key The name of the key\n         * @returns {string}\n         */\n        get: function ({key}) {\n            return getDataByKey(key);\n        },\n\n        /**\n         * Renew a data if exists.\n         * No real use. Its only purpose is to be compatible with the CookieStorage.\n         *\n         * @param {string} key The name of the key\n         * @param {boolean} session The data should be deleted when the browser session ends.\n         */\n        renew: function({key, session = false}) {\n            const value = getDataByKey(key);\n\n            if (value !== '') {\n                this.set({key: key, value: value, session: session});\n            }\n        },\n\n        /**\n         * Delete data by key.\n         *\n         * @param {string} key The name of the key\n         */\n        delete: function({key}) {\n            deleteDataByKey(key);\n        },\n    }\n};\n\nwindow['DataStorage'] = DataStorage;\n\n\n//# sourceURL=webpack://gabor-ivan-blog/./webpack/components/DataStorage.js?")},"./webpack/components/DialogWindow.js":()=>{eval("/**\n * DialogWindow component.\n * @param {object} utility\n * @param {boolean} verbose\n * @returns {*}\n */\nconst DialogWindow = function ({utility, verbose = false})\n{\n    /** @type {NodeList} */\n    let dialogElements;\n    /** @type {number} */\n    let idCounter = 1;\n    /** @type {string} */\n    const consoleColorId = '#FFA3EA';\n\n    if (!utility instanceof Utility) {\n        throw new ReferenceError('This component requires the Utility component to be loaded.');\n    }\n\n    /**\n     * A Dialog element.\n     *\n     * @param {HTMLDivElement|Node} HTMLElement\n     * @returns {*}\n     */\n    const DialogElement = function (HTMLElement)\n    {\n        const okButton = HTMLElement.querySelector('.d-buttons__ok');\n        const saveButton = HTMLElement.querySelector('.d-buttons__save');\n        const applyButton = HTMLElement.querySelector('.d-buttons__apply');\n        const deleteButton = HTMLElement.querySelector('.d-buttons__delete');\n        const cancelButton = HTMLElement.querySelector('.d-buttons__cancel');\n        const closeButton = HTMLElement.querySelector('.d-buttons__close');\n\n        const introTabSwitchButton = HTMLElement.querySelector('.d-buttons__showIntro');\n        const settingsTabSwitchButton = HTMLElement.querySelector('.d-buttons__showSettings');\n\n        const contentIntro = HTMLElement.querySelector('.d-tab.-intro');\n        const contentSettings = HTMLElement.querySelector('.d-tab.-settings');\n\n        const openDialog = function() {\n            HTMLElement.style.display = 'block';\n            verbose && console.info(\n                '%c[Dialog Window]%c ⚡%c \"'+HTMLElement.id+'\" Dialog window is opened : %o',\n                'background:'+consoleColorId+';color:black;font-weight:bold;',\n                'color:orange;font-weight:bold',\n                'color:#599bd6;font-style:italic',\n                HTMLElement.id\n            );\n        };\n\n        const dialogName = HTMLElement.dataset.name;\n\n        /**\n         * Closes the modal window\n         */\n        const closeDialog = function () {\n            HTMLElement.style.display = 'none';\n            verbose && console.info(\n                '%c[Dialog Window]%c ⚡%c \"'+HTMLElement.id+'\" Dialog window is closed : %o',\n                'background:'+consoleColorId+';color:black;font-weight:bold;',\n                'color:orange;font-weight:bold',\n                'color:#599bd6;font-style:italic',\n                HTMLElement.id\n            );\n        };\n\n        /**\n         * Button click events\n         */\n        okButton && okButton.addEventListener('click', function () {\n            utility.triggerEvent({element: HTMLElement, eventName: 'Component.Dialog.Action.OK'});\n            closeDialog();\n        });\n\n        saveButton && saveButton.addEventListener('click', function () {\n            utility.triggerEvent({element: HTMLElement, eventName: 'Component.Dialog.Action.Save'});\n            closeDialog();\n        });\n\n        applyButton && applyButton.addEventListener('click', function () {\n            utility.triggerEvent({element: HTMLElement, eventName: 'Component.Dialog.Action.Apply'});\n            closeDialog();\n        });\n\n        deleteButton && deleteButton.addEventListener('click', function () {\n            utility.triggerEvent({element: HTMLElement, eventName: 'Component.Dialog.Action.Delete'});\n            closeDialog();\n        });\n\n        cancelButton && cancelButton.addEventListener('click', function () {\n            utility.triggerEvent({element: HTMLElement, eventName: 'Component.Dialog.Action.Cancel'});\n            closeDialog();\n        });\n\n        closeButton && closeButton.addEventListener('click', function () {\n            utility.triggerEvent({element: HTMLElement, eventName: 'Component.Dialog.Action.Close'});\n            closeDialog();\n        });\n\n        settingsTabSwitchButton && settingsTabSwitchButton.addEventListener('click', function () {\n            contentIntro.classList.remove('-active');\n            contentSettings.classList.add('-active');\n        });\n\n        introTabSwitchButton && introTabSwitchButton.addEventListener('click', function () {\n            contentIntro.classList.add('-active');\n            contentSettings.classList.remove('-active');\n        });\n\n        verbose && console.info(\n            '%c[Dialog Window]%c ✚%c the \"'+HTMLElement.id+'\" Dialog element is initialized %o',\n            'background:'+consoleColorId+';color:black;font-weight:bold;',\n            'color:green; font-weight:bold;',\n            'color:#599bd6;font-style:italic',\n            '#'+HTMLElement.getAttribute('id')\n        );\n\n        return {\n            getName: function() {\n                return dialogName;\n            },\n\n            /**\n             * Opens the modal window.\n             */\n            open: function() {\n                openDialog();\n            },\n\n            /**\n             * Closes the modal window\n             */\n            close: function () {\n                closeDialog();\n            }\n        }\n    };\n\n    /**\n     * Get a Dialog element by name.\n     *\n     * @param {String} dialogName The unique name of the Dialog element.\n     * @returns {DialogElement|null}\n     */\n    const getDialogByName = function(dialogName)\n    {\n        let dialogElement = null;\n\n        dialogElements.forEach(function (element) {\n            if (typeof element.component !== 'undefined') {\n                if (element.component.getName() === dialogName) {\n                    dialogElement = element.component;\n                }\n            }\n        });\n\n        return dialogElement;\n    };\n\n    /**\n     * Initializes the component and collects the elements.\n     */\n    const initialize = function ()\n    {\n        verbose && console.info(\n            '%c[Dialog Window]%c ...looking for Dialog elements.',\n            'background:'+consoleColorId+';color:black;font-weight:bold;',\n            'color:#599bd6;font-style:italic'\n        );\n\n        dialogElements = document.querySelectorAll('.DialogWindow');\n        dialogElements.forEach(function (element) {\n            if (!element.hasAttribute('id')) {\n                element.setAttribute('id', 'dialog-' + (idCounter++));\n            }\n\n            element.component = new DialogElement(element);\n        });\n\n        utility.triggerEvent({element: document, eventName: 'Component.DialogWindow.Ready', delay: 1});\n    };\n\n    verbose && console.info(\n        '%c[Dialog Window]%c ✔%c The Dialog component loaded.',\n        'background:'+consoleColorId+';color:black;font-weight:bold;',\n        'color:green; font-weight:bold;',\n        'color:#599bd6; font-weight:bold;'\n    );\n\n    initialize();\n\n    return {\n        /**\n         * Returns the collection of dialog-elements\n         *\n         * @return {NodeList}\n         */\n        getAllDialogs: function () {\n            return dialogElements;\n        },\n\n        /**\n         *\n         * @param {String} name\n         */\n        getDialogByName: function({name}) {\n            return getDialogByName(name);\n        }\n    };\n};\n\nwindow['DialogWindow'] = DialogWindow;\n\n\n//# sourceURL=webpack://gabor-ivan-blog/./webpack/components/DialogWindow.js?")},"./webpack/components/FeatureToggleSwitch.js":()=>{eval("/**\n * Feature Toggle component.\n *\n * @param {object} utility\n * @param {object} storage\n * @param {object} featureToggleTargets\n * @param {boolean} verbose\n * @returns {*}\n */\nconst FeatureToggleSwitch = function ({utility, storage, options = {}, verbose = false})\n{\n    /** @type {NodeList} */\n    let featureToggleSwitches;\n    /** @type {number} */\n    let idCounter = 1;\n    /** @type {string} */\n    const consoleColorId = '#FF9B49';\n\n    if (!utility instanceof Utility) {\n        throw new ReferenceError('This component requires the Utility component to be loaded.');\n    }\n\n    if (!storage instanceof CookieStorage || !storage instanceof DataStorage) {\n        throw new ReferenceError('This component requires either the CookieStorage or the LocalStorage component to be loaded.');\n    }\n\n    /**\n     * A Feature Toggle Switch element\n     *\n     * @param {HTMLDivElement|Node} HTMLElement\n     * @param {String} featureName\n     * @param {{state: boolean, label: string, storageKey: string}} toggleOptions\n     * @returns {*}\n     */\n    const FeatureToggleSwitchElement = function (HTMLElement, featureName, toggleOptions)\n    {\n        // Wipe out any dirt\n        HTMLElement.innerHTML = '';\n\n        let state = storage.get({key: toggleOptions.storageKey}) === 'On'\n            ? true\n            : toggleOptions.state;\n\n        const checkbox = document.createElement('input');\n        checkbox.setAttribute('type', 'checkbox');\n        checkbox.setAttribute('id', HTMLElement.id + '-' + featureName);\n        checkbox.addEventListener('change', function () {\n            toggleSwitch(featureName)\n        });\n\n        const label = document.createElement('label');\n        label.setAttribute('for', HTMLElement.id + '-' + featureName);\n        const labelText = document.createElement('span');\n        labelText.innerHTML =  toggleOptions.label;\n        const labelSwitch = document.createElement('span');\n        label.appendChild(labelText);\n        label.appendChild(labelSwitch);\n\n        HTMLElement.appendChild(checkbox);\n        HTMLElement.appendChild(label);\n\n        /**\n         *\n         * @param {Boolean} setActive\n         */\n        const switchState = function(setActive) {\n            state = setActive;\n            document.getElementById(HTMLElement.id + '-' + featureName).checked = state;\n            storage.set({key: toggleOptions.storageKey, value: (state ? 'On' : 'Off')});\n        };\n\n        switchState(state);\n\n        verbose && console.info(\n            '%c[Feature Toggle Switch]%c ✚%c a switch element initialized %o',\n            'background:'+consoleColorId+';color:black;font-weight:bold;',\n            'color:green; font-weight:bold;',\n            'color:#599bd6;font-style:italic',\n            '#'+HTMLElement.getAttribute('id')\n        );\n\n        return {\n            /**\n             * Returns the feature name.\n             *\n             * @returns {String}\n             */\n            getFeatureName : function() {\n                return featureName;\n            },\n\n            /**\n             * Returns the current state.\n             *\n             * @returns {String}\n             */\n            getState : function () {\n                return state ? 'on' : 'off';\n            },\n\n            /**\n             * Toggles the switch on.\n             */\n            on : function() {\n                switchState(true);\n            },\n\n            /**\n             * Toggles the switch off.\n             */\n             off : function () {\n                switchState(false);\n            }\n        }\n    };\n\n    /**\n     * Initialize the component handler.\n     */\n    const initialize = function(reScan = false)\n    {\n        !reScan && verbose && console.info(\n            '%c[Feature Toggle Switch]%c ...looking for Feature Toggle Switch elements.',\n            'background:'+consoleColorId+';color:black;font-weight:bold;',\n            'color:#599bd6;font-style:italic'\n        );\n\n        featureToggleSwitches = document.querySelectorAll('.FeatureToggle[data-feature]');\n\n        featureToggleSwitches.forEach(function (element) {\n            if (typeof element.component === 'undefined') {\n                /** @type {HTMLDivElement|Node} element */\n                if (!element.hasAttribute('id')) {\n                    element.setAttribute('id', 'featureToggle' + (idCounter++));\n                }\n\n                const featureName = element.dataset.feature;\n                const featureValue = 'value' in element.dataset ? element.dataset.value : 'off';\n                const state = featureValue !== 'off';\n                const toggleOptions = (typeof options[featureName] !== 'undefined')\n                    ? options[featureName]\n                    : {state: state, label: 'Toggle feature \"'+featureName+'\" On or Off', storageKey: 'feature_'+featureName};\n\n                element.component = new FeatureToggleSwitchElement(element, featureName, toggleOptions);\n            }\n        });\n\n        !reScan && utility.triggerEvent({element: document, eventName: 'Component.FeatureToggleSwitch.Ready', delay: 1});\n    };\n\n    /**\n     * Get all FeatureToggle elements by name.\n     *\n     * @param {String} featureToggleName The non-unique name of the FeatureToggle element.\n     * @returns {[]}\n     */\n    const getElementsByName = function(featureToggleName)\n    {\n        const components = [];\n\n        featureToggleSwitches.forEach(function (element) {\n            if (typeof element.component !== 'undefined') {\n                if (element.component.getFeatureName() === featureToggleName) {\n                    components.push(element.component);\n                }\n            }\n        });\n\n        return components;\n    };\n\n    /**\n     * Toggle FeatureToggle element(s) by the given name.\n     *\n     * @param {String} featureToggleName The non-unique name of the FeatureToggle element.\n     * @return {Array}\n     */\n    const toggleSwitch = function(featureToggleName)\n    {\n        featureToggleSwitches.forEach(function (element) {\n            if (typeof element.component !== 'undefined') {\n                if (element.component.getFeatureName() === featureToggleName) {\n                    if (element.component.getState() === 'on') {\n                        element.component.off();\n                    } else {\n                        element.component.on();\n                    }\n                }\n            }\n        });\n    };\n\n    /**\n     * Toggle on/off all FeatureToggle elements.\n     *\n     * @param {String} newState The new status: 'on' or 'off'.\n     */\n    const toggleAll = function (newState = 'on')\n    {\n        if (['on', 'off'].indexOf(newState) === -1) {\n            newState = 'on';\n        }\n\n        featureToggleSwitches.forEach(function (element) {\n            if (typeof element.component !== 'undefined') {\n                if (newState === 'on') {\n                    element.component.on();\n                } else {\n                    element.component.off();\n                }\n            }\n        });\n    };\n\n    verbose && console.info(\n        '%c[Feature Toggle Switch]%c ✔%c The Feature Toggle Switch component loaded.',\n        'background:'+consoleColorId+';color:black;font-weight:bold;',\n        'color:green; font-weight:bold;',\n        'color:#599bd6; font-weight:bold;'\n    );\n\n    initialize();\n\n    return {\n        reScan: function() {\n            initialize();\n        },\n        /**\n         * Get all FeatureToggle elements by name.\n         *\n         * @param {String} featureToggleName The non-unique name of the FeatureToggle element.\n         * @returns {[]}\n         */\n        getElementsByName : function({featureToggleName}) {\n            return getElementsByName(featureToggleName);\n        },\n\n        /**\n         * Toggle FeatureToggle element(s) by the given name.\n         *\n         * @param {String} featureToggleName The non-unique name of the FeatureToggle element.\n         * @return {Array}\n         */\n        toggleSwitch : function({featureToggleName}) {\n            toggleSwitch(featureToggleName);\n        },\n\n        /**\n         * Toggle on/off all FeatureToggle elements.\n         *\n         * @param {String} newState The new status: 'on' or 'off'.\n         */\n        toggleAll : function ({newState = 'on'}) {\n            toggleAll(newState);\n        }\n    };\n};\n\nwindow['FeatureToggleSwitch'] = FeatureToggleSwitch;\n\n\n//# sourceURL=webpack://gabor-ivan-blog/./webpack/components/FeatureToggleSwitch.js?")},"./webpack/components/LazyLoadImage.js":()=>{eval("/**\n * Lazy Load Image component.\n *\n * @param {object} utility\n * @param {boolean} verbose\n * @returns {*}\n */\nconst LazyLoadImage = function ({utility, verbose = false})\n{\n    /** @type {NodeList} */\n    let lazyLoadImages;\n    /** @type {number} */\n    let idCounter = 1;\n    /** @type {string} */\n    const consoleColorId = '#BFFFF5';\n    /** @type {IntersectionObserver|IntersectionObserverFallback} */\n    let imageObserver;\n\n    if (!utility instanceof Utility) {\n        throw new ReferenceError('This component requires the Utility component to be loaded.');\n    }\n\n    const IntersectionObserverFallback = function() {\n        verbose && console.info(\n            '%c[Lazy Load Image]%c ✖%c the IntersectionObserver function is not supported. Loading images in normal mode.',\n            'background:'+consoleColorId+';color:black;font-weight:bold;',\n            'color:red',\n            'color:#599bd6;font-style:italic'\n        );\n\n        return {\n            observe: function (element) {\n                element.src = element.dataset.src;\n\n                verbose && console.info(\n                    '%c[Lazy Load Image]%c ⚡%c an image element loaded %o',\n                    'background:'+consoleColorId+';color:black;font-weight:bold;',\n                    'color:orange;font-weight:bold',\n                    'color:#599bd6;font-style:italic',\n                    '#'+element.getAttribute('id')\n                );\n            }\n        }\n    };\n\n    const intersectionObserverClass = typeof IntersectionObserver !== 'undefined'\n        ? IntersectionObserver\n        : IntersectionObserverFallback;\n\n    /**\n     * Adds lazy-load behaviour to an image element.\n     *\n     * @param {HTMLImageElement|Node} HTMLElement\n     * @returns {*}\n     */\n    const LazyLoadImageElement = function ({HTMLElement}) {\n        verbose && console.info(\n            '%c[Lazy Load Image]%c ✚%c an image element initialized %o',\n            'background:'+consoleColorId+';color:black;font-weight:bold;',\n            'color:green; font-weight:bold;',\n            'color:#599bd6;font-style:italic',\n            '#'+HTMLElement.getAttribute('id')\n        );\n\n        return {\n            /**\n             * Loads the actual image when it gets into view\n             */\n            loadImage: function () {\n                if (!HTMLElement.hasAttribute('data-src')) {\n                    return;\n                }\n                const imageSource = HTMLElement.dataset.src;\n                const preload  = new Image();\n\n                preload.addEventListener('error', function (event) {\n                    event.preventDefault();\n                    verbose && console.info(\n                        '%c[Lazy Load Image]%c ✖%c an image resource is not found: %c'+imageSource,\n                        'background:'+consoleColorId+';color:black;font-weight:bold;',\n                        'color:red',\n                        'color:#599bd6;font-style:italic',\n                        'color:red;font-style:italic'\n                    );\n                });\n\n                preload.addEventListener('load', function () {\n                    HTMLElement.src = imageSource;\n                    HTMLElement.removeAttribute('data-src');\n\n                    verbose && console.info(\n                        '%c[Lazy Load Image]%c ⚡%c an image element loaded %o',\n                        'background:'+consoleColorId+';color:black;font-weight:bold;',\n                        'color:orange;font-weight:bold',\n                        'color:#599bd6;font-style:italic',\n                        '#'+HTMLElement.getAttribute('id')\n                    );\n                });\n\n                preload.src = imageSource;\n            }\n        }\n    };\n\n    /**\n     * Initializes the loader and collects the elements.\n     */\n    const initialize = function()\n    {\n        verbose && console.info(\n            '%c[Lazy Load Image]%c ...looking for image elements.',\n            'background:'+consoleColorId+';color:black;font-weight:bold;',\n            'color:#599bd6;font-style:italic'\n        );\n\n        lazyLoadImages = document.querySelectorAll('img[data-src]');\n\n        imageObserver = new intersectionObserverClass((entries, imgObserver) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    /** @type LazyLoadImageElement lazyLoadImageElement */\n                    let lazyLoadImageElement = entry.target.component;\n                    lazyLoadImageElement.loadImage();\n                }\n            })\n        });\n\n        lazyLoadImages.forEach(function (element) {\n            if (!element.hasAttribute('id')) {\n                element.setAttribute('id', 'lazyImage' + (idCounter++));\n            }\n\n            element.component = new LazyLoadImageElement({HTMLElement: element});\n            imageObserver.observe(element);\n        });\n\n        utility.triggerEvent({element: document, eventName: 'Component.LazyLoadImage.Ready', delay: 1});\n    };\n\n    verbose && console.info(\n        '%c[Lazy Load Image]%c ✔%c The Lazy Load Image component loaded.',\n        'background:'+consoleColorId+';color:black;font-weight:bold;',\n        'color:green; font-weight:bold;',\n        'color:#599bd6; font-weight:bold;'\n    );\n\n    initialize();\n\n    return {\n        /**\n         * Returns the collection of lazy-loaded images.\n         *\n         * @returns {NodeList}\n         */\n        getLazyLoadImages: function () {\n            return lazyLoadImages;\n        }\n    };\n};\n\nwindow['LazyLoadImage'] = LazyLoadImage;\n\n\n//# sourceURL=webpack://gabor-ivan-blog/./webpack/components/LazyLoadImage.js?")},"./webpack/components/SmoothScroll.js":()=>{eval("/**\n * SmoothScroll component.\n * @param {object} utility\n * @param {boolean} verbose\n * @returns {*}\n */\nconst SmoothScroll = function ({utility, verbose = false})\n{\n    /** @type {string} */\n    const consoleColorId = '#c96352';\n\n    if (!utility instanceof Utility) {\n        throw new ReferenceError('This component requires the Utility component to be loaded.');\n    }\n\n    /**\n     * Return the actual scroll position in pixels.\n     *\n     * @return {number}\n     */\n    const getScrollPosition = function () {\n        return window.pageYOffset;\n    };\n\n    /**\n     * Return the client height in pixels.\n     *\n     * @return {number}\n     */\n    const getClientHeight = function () {\n        return document.documentElement.clientHeight;\n    }\n\n    /**\n     * Return the document height in pixels.\n     *\n     * @return {number}\n     */\n    const getDocumentHeight = function () {\n        return document.body.offsetHeight;\n    }\n\n    /**\n     * Return the maximum scroll position available in pixels.\n     * @return {number}\n     */\n    const getMaxScrollTop = function () {\n        return getDocumentHeight() - getClientHeight();\n    }\n\n    /**\n     * Return the actual scroll position of an element in the document.\n     *\n     * @param {String} elementId\n     * @return {number}\n     */\n    const getElementPosition = function (elementId) {\n        const element = document.getElementById(elementId);\n\n        if (!element) {\n            return 0;\n        }\n\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.top;\n    }\n\n    /**\n     * Takes small steps until reach the target.\n     *\n     * @param {Number} from\n     * @param {Number} to\n     */\n    const smoothScroll = function (from, to) {\n        const stepBy = 0.2;\n        const snapDistance = 1;\n        const speed = 30;\n        const diff = to - from;\n\n        if (Math.abs(diff) <= snapDistance) {\n            scrollTo(0.0, to);\n\n            verbose && console.info(\n                '%c[Smooth Scroll]%c ✔%c Scroll end.',\n                'background:'+consoleColorId+';color:black;font-weight:bold;',\n                'color:green; font-weight:bold;',\n                'color:#599bd6; font-weight:bold;',\n            );\n\n            return;\n        }\n\n        const nextPosition = (from * (1.0 - stepBy)) + (to * stepBy);\n        scrollTo(0.0, Math.round(nextPosition));\n\n        setTimeout(smoothScroll, speed, nextPosition, to);\n    }\n\n    /**\n     * Initializes the component and collects the elements.\n     */\n    const initialize = function ()\n    {\n        utility.triggerEvent({element: document, eventName: 'Component.SmoothScroll.Ready', delay: 1});\n    };\n\n    verbose && console.info(\n        '%c[Smooth Scroll]%c ✔%c The Smooth Scroll component loaded.',\n        'background:'+consoleColorId+';color:black;font-weight:bold;',\n        'color:green; font-weight:bold;',\n        'color:#599bd6; font-weight:bold;'\n    );\n\n    initialize();\n\n    return {\n        /**\n         * Return the actual scroll position in pixels.\n         *\n         * @return {number}\n         */\n        getScrollPosition: function() {\n            return getScrollPosition();\n        },\n\n        /**\n         * Return the actual scroll position of an element in the document.\n         *\n         * @param {String} elementId\n         * @return {number}\n         */\n        getElementPositionById: function({elementId}) {\n            return getElementPosition(elementId);\n        },\n\n        /**\n         * Scroll to an element specified by its ID.\n         *\n         * @param {String} elementId The ID of the HTML element to scroll\n         * @param {Number} gap       The gap to keep on top in pixels\n         */\n        scrollToElementById: function({elementId, gap}) {\n            const element = document.getElementById(elementId);\n\n            if (!element) {\n                return false;\n            }\n\n            const targetPosition = Math.min((getScrollPosition() + getElementPosition(elementId) - gap), getMaxScrollTop());\n\n            verbose && console.info(\n                '%c[Smooth Scroll]%c ✔%c Start scroll from %c%o%c to %c%o%c.',\n                'background:'+consoleColorId+';color:black;font-weight:bold;',\n                'color:green; font-weight:bold;',\n                'color:#599bd6; font-weight:bold;',\n                'color:red; font-weight:bold;',\n                getScrollPosition(),\n                'color:#599bd6; font-weight:bold;',\n                'color:red; font-weight:bold;',\n                targetPosition,\n                'color:#599bd6; font-weight:bold;',\n            );\n\n            smoothScroll(getScrollPosition(), targetPosition);\n        }\n    };\n};\n\nwindow['SmoothScroll'] = SmoothScroll;\n\n\n//# sourceURL=webpack://gabor-ivan-blog/./webpack/components/SmoothScroll.js?")},"./webpack/components/Utility.js":()=>{eval("/**\n * Utility component.\n *\n * @param {boolean} verbose\n * @returns {*}\n */\nconst Utility = function ({verbose = false})\n{\n    /** @type {string} */\n    const consoleColorId = '#d7cfff';\n\n    /**\n     * Converts a form data to object\n     *\n     * @param {FormData} formData\n     * @return {Object}\n     */\n    const formDataToObject = function ({formData})\n    {\n        const object = {};\n\n        formData.forEach(function (value, key) {\n            object[key] = value;\n        });\n\n        return object;\n    };\n\n    /**\n     * Converts an object to form data\n     *\n     * @param {Object} object\n     * @return {FormData}\n     */\n    const objectToFormData = function ({object})\n    {\n        const formData = new FormData();\n\n        for (let attribute in object) {\n            if (object.hasOwnProperty(attribute)) {\n                formData.append(attribute, object[attribute]);\n            }\n        }\n\n        return formData\n    };\n\n    /**\n     * Initialize component\n     */\n    const initialize = function()\n    {\n        setTimeout(function() { triggerEvent(document, 'Component.Utility.Ready', null) }, 1);\n    };\n\n    /**\n     * Makes an XmlHttpRequest.\n     *\n     * @param {string} url\n     * @param {string} method\n     * @param {boolean} async\n     * @param {string} enctype\n     * @param {FormData|object} data\n     * @param {null|function} successCallback\n     * @param {null|function} failureCallback\n     * @returns {XMLHttpRequest}\n     */\n    const doXmlHttpRequest = function(url, method, async, enctype, data, successCallback, failureCallback)\n    {\n        const rnd = new Date().getTime();\n        url = url + (url.lastIndexOf('?') === -1 ? '?' : '&') + 'timestamp=' + rnd;\n\n        const xhr = new XMLHttpRequest();\n        xhr.open(method, url, async);\n\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState === XMLHttpRequest.DONE) {\n                try {\n                    if (xhr.status === 200) {\n                        successCallback(xhr.responseText);\n                    } else {\n                        failureCallback(xhr.responseText);\n                    }\n                } catch (exp) {\n                    verbose && console.warn('JSON parse error. Continue', exp);\n                }\n            }\n        };\n\n        // if NOT multipart/form-data, turn the FromData into object\n        if (data instanceof FormData && enctype !== 'multipart/form-data') {\n            data = formDataToObject(data);\n        }\n\n        // if mulitpart/form-data, turn the data into FormData\n        if (!data instanceof FormData && enctype === 'multipart/form-data') {\n            data = objectToFormData(data);\n        }\n\n        switch (enctype) {\n            case 'application/json':\n                data = JSON.stringify(data);\n                xhr.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');\n                break;\n\n            case 'application/x-www-form-urlencoded':\n                data = Object.keys(data).map(function (key) {\n                    return key + '=' + data[key]\n                }).join('&');\n                xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');\n                break;\n\n            case 'multipart/form-data':\n                xhr.setRequestHeader('Content-Type', 'multipart/form-data');\n                break;\n        }\n\n        xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n        xhr.send(data);\n\n        return xhr;\n    };\n\n    /**\n     * Fetches a URL\n     *\n     * @param {string} url\n     * @param {string} method\n     * @param {boolean} async\n     * @param {string} enctype\n     * @param {FormData|object} data\n     * @param {null|function} successCallback\n     * @param {null|function} failureCallback\n     * @return Promise\n     */\n    const doFetch = function(url, method, async, enctype, data, successCallback, failureCallback)\n    {\n        switch (enctype) {\n            case 'application/json':\n                if (data instanceof FormData) {\n                    data = formDataToObject(data);\n                }\n\n                data = JSON.stringify(data);\n                break;\n\n            case 'application/x-www-form-urlencoded':\n                if (data instanceof FormData) {\n                    data = formDataToObject(data);\n                }\n\n                data = Object.keys(data).map(function (key) {\n                    return key + '=' + data[key]\n                }).join('&');\n                break;\n\n            case 'multipart/form-data':\n                if (!data instanceof FormData) {\n                    data = objectToFormData(data);\n                }\n                break;\n        }\n\n        const request = {\n            method: method,\n            headers: {\n                'Content-Type': enctype,\n                'X-Requested-With': 'XMLHttpRequest'\n            }\n        };\n\n        if (method !== 'GET' && method !== 'HEAD') {\n            request.body = data;\n        }\n\n        verbose && console.info(\n            '%c[Utility]%c ⚡%c Fetching URL %o',\n            'background:'+consoleColorId+';color:black;font-weight:bold;',\n            'color:orange;font-weight:bold',\n            'color:#599bd6;font-style:italic',\n            url\n        );\n\n        return fetch(url, request)\n            .then(function (response) {\n                if (response.ok) {\n                    verbose && console.info(\n                        '%c[Utility]%c ✔%c URL fetch successful',\n                        'background:'+consoleColorId+';color:black;font-weight:bold;',\n                        'color:green;font-weight:bold',\n                        'color:#599bd6;font-style:italic'\n                    );\n\n                    return successCallback(response);\n                } else {\n                    const error = new Error(response.statusText || response.status);\n                    error.response = response;\n\n                    verbose && console.info(\n                        '%c[Utility]%c ✖%c URL fetch failed',\n                        'background:'+consoleColorId+';color:black;font-weight:bold;',\n                        'color:red',\n                        'color:#599bd6;font-style:italic'\n                    );\n\n\n                    return failureCallback(error);\n                }\n            });\n    };\n\n    /**\n     * Triggers an event on an element.\n     *\n     * @param {*}       element\n     * @param {string}  eventName\n     * @param {*}       [customData]\n     */\n    const triggerEvent = function (element, eventName, customData)\n    {\n        let event;\n\n        if (customData !== null) {\n            event = new CustomEvent(eventName, {'detail': customData})\n        } else {\n            event = new Event(eventName);\n        }\n\n        verbose && console.info(\n            '%c[Utility]%c ⚡%c Triggering event: %o',\n            'background:'+consoleColorId+';color:black;font-weight:bold;',\n            'color:orange;font-weight:bold',\n            'color:#599bd6;font-style:italic',\n            eventName\n        );\n\n        element.dispatchEvent(event);\n    };\n\n    /**\n     * Returns the event element path.\n     *\n     * @param {Event} event\n     * @return {Array}\n     */\n    const getEventPath = function (event)\n    {\n        let path = (event.composedPath && event.composedPath()) || event.path,\n            target = event.target;\n\n        if (typeof path !== 'undefined') {\n            // Safari doesn't include Window, and it should.\n            path = (path.indexOf(window) < 0) ? path.concat([window]) : path;\n            return path;\n        }\n\n        if (target === window) {\n            return [window];\n        }\n\n        function getParents(node, memo)\n        {\n            memo = memo || [];\n            const parentNode = node.parentNode;\n\n            if (!parentNode) {\n                return memo;\n            } else {\n                return getParents(parentNode, memo.concat([parentNode]));\n            }\n        }\n\n        return [target]\n            .concat(getParents(target))\n            .concat([window]);\n    };\n\n    /**\n     * Tries to figure out the operating system\n     *\n     * @returns {string}\n     */\n    const getDeviceOs = function()\n    {\n        let operatingSystem = 'Unknown';\n        const patterns = ['Win', 'Mac', 'X11', 'Linux', 'iPhone', 'iPad', 'Android'];\n        const supportedOperatingSystems = ['Windows', 'MacOS', 'Unix', 'Linux', 'iOS', 'iOS', 'Android'];\n\n        for (let i in patterns) {\n            if (navigator.platform.indexOf(patterns[i]) !== -1) {\n                operatingSystem = supportedOperatingSystems[i];\n            }\n        }\n\n        return operatingSystem;\n    };\n\n    verbose && console.info(\n        '%c[Utility]%c ✔%c The Utility Component loaded.',\n        'background:'+consoleColorId+';color:black;font-weight:bold;',\n        'color:green; font-weight:bold;',\n        'color:#599bd6; font-weight:bold;'\n    );\n\n    initialize();\n\n    return {\n        /**\n         * Makes an XmlHttpRequest.\n         *\n         * @param {string} url\n         * @param {string} method\n         * @param {boolean} async\n         * @param {string} enctype\n         * @param {FormData|object} data\n         * @param {null|function} successCallback\n         * @param {null|function} failureCallback\n         * @returns {XMLHttpRequest}\n         */\n        ajax : function ({url = '/', method = 'POST', async = true, enctype = 'application/json', data = {}, successCallback = null, failureCallback = null}) {\n            if (typeof successCallback !== 'function') {\n                successCallback = function (data) {};\n            }\n\n            if (typeof failureCallback !== 'function') {\n                failureCallback =  function (data) {};\n            }\n\n            return doXmlHttpRequest(url, method, async, enctype, data, successCallback, failureCallback);\n        },\n\n        /**\n         * Fetches a URL\n         *\n         * @param {string} url\n         * @param {string} method\n         * @param {boolean} async\n         * @param {string} enctype\n         * @param {FormData|object} data\n         * @param {null|function} successCallback\n         * @param {null|function} failureCallback\n         * @return Promise\n         */\n        fetch: function ({url = '/', method = 'POST', async = true, enctype = 'application/json', data = {}, successCallback = null, failureCallback = null}) {\n            if (typeof successCallback !== 'function') {\n                successCallback = function (data) {\n                    return new Promise((resolve, reject) => {\n                        resolve(data);\n                    });\n                };\n            }\n\n            if (typeof failureCallback !== 'function') {\n                failureCallback =  function (data) {\n                    new Promise((resolve, reject) => {\n                        reject(data);\n                    });\n                };\n            }\n\n            return doFetch(url, method, async, enctype, data, successCallback, failureCallback);\n        },\n\n        /**\n         * Triggers an event on an element.\n         *\n         * @param {*}      element\n         * @param {string} eventName\n         * @param {*}      [customData]\n         * @param {number} delay\n         */\n        triggerEvent : function ({element, eventName, customData = null, delay = 0}) {\n            if (delay === 0) {\n                triggerEvent(element, eventName, customData);\n            } else {\n                setTimeout(function() { triggerEvent(element, eventName, customData) }, delay);\n            }\n        },\n\n        /**\n         * Returns the event element path.\n         *\n         * @param {Event} event\n         * @return {Array}\n         */\n        getEventPath: function ({event}) {\n            return getEventPath(event);\n        },\n\n        /**\n         * Tries to figure out the operating system\n         *\n         * @returns {string}\n         */\n        getDeviceOs: function () {\n            return getDeviceOs();\n        },\n\n        /**\n         * Reads the pure stylesheets and collects all the Chart styles before rendering\n         *\n         * @param {String} className\n         * @return {object}\n         */\n        readStylesheetsByClassName: function({className}) {\n            let styles = document.styleSheets;\n            let localStyles = {};\n            let classes;\n            let currentStyle = null;\n\n            for (let i = 0, styleNum = styles.length; i < styleNum; i++) {\n                try {\n                    classes = styles[i].rules || styles[i].cssRules || new CSSRuleList();\n                    for (let j = 0, ruleNum = classes.length; j < ruleNum; j ++) {\n                        currentStyle = classes[j];\n                        if (currentStyle instanceof CSSImportRule || currentStyle instanceof CSSMediaRule) {\n                            continue;\n                        }\n\n                        if (classes[j].selectorText.indexOf('.'+className) !== -1) {\n                            localStyles[classes[j].selectorText] = {};\n                            let customDefinitions = [];\n\n                            for (let key in classes[j].style) {\n                                if (classes[j].style.hasOwnProperty(key) && !isNaN(key)) {\n                                    customDefinitions.push(classes[j].style[key].replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); }));\n                                }\n                            }\n\n                            for (let l = 0, definitionLength = customDefinitions.length; l < definitionLength; l++) {\n                                localStyles[classes[j].selectorText][customDefinitions[l]] = classes[j].style[customDefinitions[l]];\n                            }\n                        }\n                    }\n                } catch (exception) {\n                    console.warn(exception);\n                }\n            }\n            return localStyles;\n        }\n    };\n};\n\nwindow['Utility'] = Utility;\n\n\n//# sourceURL=webpack://gabor-ivan-blog/./webpack/components/Utility.js?")},"./webpack/entry.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(/*! ./components/Utility */ \"./webpack/components/Utility.js\");\n__webpack_require__(/*! ./components/SmoothScroll */ \"./webpack/components/SmoothScroll.js\");\n__webpack_require__(/*! ./components/DataStorage */ \"./webpack/components/DataStorage.js\");\n__webpack_require__(/*! ./components/CookieStorage */ \"./webpack/components/CookieStorage.js\");\n__webpack_require__(/*! ./components/FeatureToggleSwitch */ \"./webpack/components/FeatureToggleSwitch.js\");\n__webpack_require__(/*! ./components/LazyLoadImage */ \"./webpack/components/LazyLoadImage.js\");\n__webpack_require__(/*! ./components/DialogWindow */ \"./webpack/components/DialogWindow.js\");\n__webpack_require__(/*! ./components/BarChart */ \"./webpack/components/BarChart.js\");\n__webpack_require__(/*! ./components/Collapsible */ \"./webpack/components/Collapsible.js\");\n\nwindow['Components'] = {};\nconst verboseLog = true;\nlet utility = new Utility({verbose: verboseLog});\n\ndocument.addEventListener('Component.Utility.Ready', function () {\n    let dataStorage;\n\n    try {\n        dataStorage = new DataStorage({utility: utility, verbose: verboseLog});\n    } catch (e) {\n        dataStorage = new CookieStorage({utility: utility, verbose: verboseLog});\n    }\n\n    window.Components.utility = utility;\n    window.Components.dataStorage = dataStorage;\n    window.Components.smoothScoll = new SmoothScroll({utility: utility, verbose: verboseLog});\n    window.Components.lazyLoadImage = new LazyLoadImage({utility: utility, verbose: verboseLog});\n    window.Components.barChart = new BarChart({utility: utility, verbose: verboseLog});\n    window.Components.collapsible = new Collapsible({utility: utility, verbose: verboseLog});\n    window.Components.featureToggle = new FeatureToggleSwitch({utility: utility, storage: dataStorage, verbose: verboseLog});\n\n    Promise.allSettled(fetchDialogs()).then(function(response) {\n        window.Components.dialogWindow = new DialogWindow({utility: utility, verbose: verboseLog});\n    });\n});\n\n/**\n *Add smooth scroll function for content anchor link.\n */\ndocument.addEventListener('Component.SmoothScroll.Ready', function() {\n    const scrollToContentButton = document.querySelector('.m-menu__link.-downarrow');\n\n    if (scrollToContentButton) {\n        scrollToContentButton.addEventListener('click', function(event){\n            event.preventDefault();\n\n            window.Components.smoothScoll.scrollToElementById({elementId: 'content', gap: 10});\n        });\n    }\n});\n\n/**\n * Open the dialog as soon as the Component is ready\n */\ndocument.addEventListener('Component.DialogWindow.Ready', function() {\n    const alterEgoDialog = window.Components.dialogWindow.getDialogByName({name: 'alterego'});\n\n    if (alterEgoDialog) {\n        alterEgoDialog.open();\n        window.Components.dataStorage.set({key: 'alterego', value: 'On', session: true})\n    }\n});\n\n/**\n * Fetches all the dialog HTML data.\n *\n * @return {[]}\n */\nfunction fetchDialogs()\n{\n    let promises = [];\n\n    const utility = window.Components.utility;\n    const dataStorage = window.Components.dataStorage;\n\n    const dialogDisplayOnceForSession = [\n        'alterego'\n    ];\n\n    const wrapperId = 'dialogWrapper_'+Math.ceil(Math.random()*1000000000);\n    let dialogWrapper = document.getElementById(wrapperId);\n\n    if (!dialogWrapper) {\n        dialogWrapper = document.createElement('div');\n        dialogWrapper.setAttribute('id', wrapperId);\n        document.body.appendChild(dialogWrapper);\n    }\n\n    for (let i = 0, num = dialogDisplayOnceForSession.length; i < num; i++) {\n        if (dataStorage.get({key: dialogDisplayOnceForSession[i]}) !== 'On') {\n            promises.push(utility.fetch({\n                url: '/dialogs/'+dialogDisplayOnceForSession[i]+'.html',\n                method: 'GET',\n                enctype: 'text/html',\n                successCallback: function (response) {\n                    return response.text().then(function (data) {\n\n                        dialogWrapper.innerHTML += data;\n\n                        return new Promise((resolve, reject) => {\n                            resolve('done');\n                        });\n                    });\n                }\n            }));\n        }\n    }\n\n    return promises;\n}\n\n\n//# sourceURL=webpack://gabor-ivan-blog/./webpack/entry.js?")}},__webpack_module_cache__={};function __webpack_require__(n){var e=__webpack_module_cache__[n];if(void 0!==e)return e.exports;var t=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](t,t.exports,__webpack_require__),t.exports}var __webpack_exports__=__webpack_require__("./webpack/entry.js")})();